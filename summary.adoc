= Summary

== _Chapter 17_ , _HTTP_

The Hypertext Transfer Protocol, is the mechanism through which data is
requested and provided on the World Wide Web.

=== The protocol

when you search a url in the browser, for example
_eloquentjavascript.net/17_http.html_, the browser first looks up the address of
 the server associated with _eloquentjavascript.net_ and tries to open a TCP
 connection to it on port 80, the default port for HTTP traffic. If the server
 exists and accepts the connection, the browser sends something like this:

[source, Shell]
----
GET /17_http.html HTTP/1.1
Host: eloquentjavascript.net
User-Agent: Your browser's name
----

The server responds:
[source, Shell]
----
HTTP/1.1 200 OK
Content-Length: 65585
Content-Type: text/html
Last-Modified: Wed, 09 Apr 2014 10:48:09 GMT

<!doctype html>
... the rest of the document
----

The browser then takes the part of the response after the blank line and
displays it as an HTML document.

The client can send different request to the server.

* _GET_ means that we want to get the specified resource.
* _DELETE_ to delete a resource.
* _PUT_ to replace it.
* _POST_ to send information to it.


After the resource path, the first line of the request mentions HTTP/1.1 to
indicate the version of the HTTP protocol it is using. The server’s response
will start with a version as well, followed by the status of the response, first
 as a three-digit status code and then as a human-readable string.

[source, Shell]
----
HTTP/1.1 200 OK
----

*Codes:*

* If the status codes start with a _2_ indicate that the request succeeded.

* Codes starting with _4_ mean there was something wrong with the request.

* Codes that start with _5_ mean an error happened on the server and the request
 is not to blame.

The request or response can be followed by any number of headers with the
 format _name: value_.

[source, Shell]
----
Content-Length: 65585
Content-Type: text/html
Last-Modified: Wed, 09 Apr 2014 10:48:09 GMT
----

The client or the server decides which headers to include in a request or a
response. After the headers it can have the body with the data being sent. GET
and DELETE requests don’t send along any data, but PUT and POST requests do.

=== Browsers and HTTP

The browser will make a request when we enter a URL in its address bar or the
HTML page references other files. Browsers will make requests simultaneously
using GET requests.

[source, html]
.This is a example of a _form_.
----
include::src/browser-and-http/index.html[tag=code]
----

This code describes a form with two fields a small one asking for a name and a larger one to write a message in. When you send the information the field will encoded into a query string.

*  When the <form> element’s method attribute is GET the query string is tacked
onto the action URL, and the browser makes a GET request to that URL.

[source, Shell]
----
GET /example/message.html?name=Jean&message=Yes%3F HTTP/1.1
----

The query string is started with a question mark, after that follow pairs of
names and values separated with a ampersand character (&). Some characters in
query strings must be escaped.

[source, Javascript]
.link:/http-KevMCh/src/browser-and-http/uri-component.html[URI Component]
----
include::src/browser-and-http/uri-component.html[tag=code]
----

* If we use the POST method the form put the query string in body of the
request.

[source, Shell]
----
POST /example/message.html HTTP/1.1
Content-length: 24
Content-type: application/x-www-form-urlencoded

name=Jean&message=Yes%3F
----

=== XMLHttpRequest

The interface allows you to parse response documents as XML if you want, making
a request and parsing the response. When the XMLHttpRequest interface was added
to Internet Explorer, it allowed people to do things with JavaScript that had
been very hard before. The interface through which browser JavaScript can make
HTTP requests is called XMLHttpRequest. The other significant browser at that
time, Mozilla (later Firefox), did not want to be left behind. Mozilla copied
the interface, including the bogus name. The next generation of browsers
followed this example, and today XMLHttpRequest is a de facto standard
interface.

=== Sending a request

Simple request. We create a request object with the XMLHttpRequest constructor
and call its open and send methods.

The open method configures the request. In this case, we choose to make a GET
request. After opening the request, we can send it with the send method. The
argument to send is the request body. For GET requests, we can pass null. If the
 third argument to open was false, send will return only after the response to
 our request was received. We can read the request object’s responseText
 property to get the response body. The other information included in the
 response can also be extracted from this object.

[source, Javascript]
----
include::src/sending-a-request/index.html[tag=code]
----

=== Asynchronous Requests

If we pass true as the third argument to open, the request is asynchronous. This
 means that when we call send, the only thing that happens right away is that
 the request is scheduled to be sent. Our program can continue, and the browser
 will take care of the sending and receiving of data in the background. But as
 long as the request is running, we won’t be able to access the response. We
 need a mechanism that will notify us when the data is available. For this, we
 must listen for the "load" event on the request object.

[source, Javascript]
----
include::src/asynchronous-requests/index.html[tag=code]
----

=== Fetching XML Data

When the resource retrieved by an XMLHttpRequest object is an XML document, the
object’s responseXML property will hold a parsed representation of this
document. The object that responseXML holds corresponds to the document object.
Its documentElement property refers to the outer tag of the XML document.

[source,xml]
----
<fruits>
  <fruit name="banana" color="yellow"/>
  <fruit name="lemon" color="yellow"/>
  <fruit name="cherry" color="red"/>
</fruits>
----

[source, Javascript]
.File result with xml file.
----
include::src/fetching-xml-data/index.html[tag=code1]
----

XML documents can be used to exchange structured information with the server,
but is better using JSON data which is easier to read and write.

[source, Javascript]
.File result with json file.
----
include::src/fetching-xml-data/index.html[tag=code2]
----

=== HTTP sandboxing

Making HTTP requests in web page scripts once again raises concerns about security. The person who controls the script might not have the same interests as the person on whose computer it is running. It is possible for websites to protect themselves against attacks, but that requires effort, and many websites fail to do it. For this reason, browsers protect us by disallowing scripts to make HTTP requests to other domains. This can be an annoying problem when building systems that want to access several domains for legitimate reasons. Fortunately, servers can include a header like this in their response to explicitly indicate to browsers that it is okay for the request to come from other domains:

_Access-Control-Allow-Origin: *_
